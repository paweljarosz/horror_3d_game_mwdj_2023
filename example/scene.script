--
-- Local

local urls = { }

local daycycle = {
  {
    sunlight_direction = vmath.vector3(-70, 90, 0),
    sunlight_color = vmath.vector3(0.5, 0.5, 0.5),
    sunlight_brightness = 0.5,
    ambient_color = vmath.vector3(0.5, 0.5, 0.5),
    ambient_level = 0.2,
    fog_color = vmath.vector3(0),
    fog_level = 0.3,
    fog_distance_min = 6,
    fog_distance_max = 8,
    duration = 0
  },
  {
    sunlight_direction = vmath.vector3(-70, 80, 0),
    sunlight_color = vmath.vector3(0.29, 0.28, 0.65),
    sunlight_brightness = 0.45,
    ambient_color = vmath.vector3(0.09, 0.08, 0.15),
    ambient_level = 0.05,
    fog_color = vmath.vector3(0),
    fog_level = 0.6,
    fog_distance_min = 10,
    fog_distance_max = 15,
    duration = 0
  }
}

local function run_daycycle(self, index)
  local target = daycycle[index or 1]
  local duration = index and target.duration or 0
  --local index = index or 1
  --go.animate(urls.illumination_go, 'euler', go.PLAYBACK_ONCE_FORWARD, target.sunlight_direction, go.EASING_LINEAR, duration, 0, function()
    --run_daycycle(self, index == #daycycle and 1 or (index + 1))
  --end)

  go.cancel_animations(urls.illumination)
  go.animate(urls.illumination, 'sunlight_color', go.PLAYBACK_ONCE_FORWARD, target.sunlight_color, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'sunlight_brightness', go.PLAYBACK_ONCE_FORWARD, target.sunlight_brightness, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'ambient_color', go.PLAYBACK_ONCE_FORWARD, target.ambient_color, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'ambient_level', go.PLAYBACK_ONCE_FORWARD, target.ambient_level, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'fog_level', go.PLAYBACK_ONCE_FORWARD, target.fog_level, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'fog_color', go.PLAYBACK_ONCE_FORWARD, target.fog_color, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'fog_distance_min', go.PLAYBACK_ONCE_FORWARD, target.fog_distance_min, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'fog_distance_max', go.PLAYBACK_ONCE_FORWARD, target.fog_distance_max, go.EASING_LINEAR, duration)
end

-- Distance between two 2d points
local function dist2d(x1, y1, x2, y2)
  return ((x2-x1)^2+(y2-y1)^2)^0.5 -- removed sqr on purpose
end

local papers = {}
papers[1] = 1

local grass_scale = 2
local grass_space = 4
local grass_fov = 8--12
local remove_grass_fov = 20

local tree_density = 26
local tree_1_probability = 100 - tree_density
local tree_2_probability = 100 - 2 * tree_density
local tree_3_probability = 100 - 3 * tree_density

local function get_normalized_hero_position()
  local hero_pos = go.get_world_position("main:/player/player")
  hero_pos.x = math.floor(hero_pos.x)
  hero_pos.z = math.ceil(hero_pos.z)
  hero_pos.x = hero_pos.x - (hero_pos.x % grass_space)
  hero_pos.z = hero_pos.z - (hero_pos.z % grass_space)
  return hero_pos
end

local instance_counter = 0

local function remove_far_grass_and_trees(spawned_objects, hero_pos)
  for obj_x, z_column in pairs(spawned_objects) do
    for obj_z, objects in pairs(z_column) do
      if dist2d(hero_pos.x, hero_pos.z, obj_x, obj_z) > remove_grass_fov then
        -- Remove far grass
        go.delete(objects.grass)
        instance_counter = instance_counter - 1

        -- Eventually remove trees
        if objects.tree then
          go.delete(objects.tree)
          instance_counter = instance_counter - 1
        end

        -- Eventually remove papers
        if objects.paper then
          go.delete(objects.paper)
          instance_counter = instance_counter - 1
        end

        -- Eventually remove lights
        if objects.light then
          go.delete(objects.light)
          instance_counter = instance_counter - 1
        end
        spawned_objects[obj_x][obj_z] = nil
      end
    end
  end
end

local function spawn_paper(spawned_objects, grid, pos, paper_delta, rot, number)
  if (papers[number] > 0) and (math.random(0,10) >= 0) then
    pos = pos + paper_delta
    print("SPAWNED PAPER at", grid.x,grid.z)
    spawned_objects[grid.x][grid.z].paper = factory.create("#paper"..number, pos, rot, _, vmath.vector3(0.17))
    spawned_objects[grid.x][grid.z].light = factory.create("#light", pos, _,
    {specular = 1, smoothness = 0.5, cutoff = 0.5, color = vmath.vector3(1,0,0)})
    instance_counter = instance_counter + 2
    papers[number] = papers[number] - 1
  end
end

local function create_near_grass_and_trees(spawned_objects, hero_pos)
  for x = -grass_fov, grass_fov, grass_space do
    for z = -grass_fov, grass_fov, grass_space do
      local grid = vmath.vector3(hero_pos.x + x, 0, hero_pos.z + z)
      local pos = vmath.vector3(hero_pos.x + x, 0, hero_pos.z + z)
      spawned_objects[grid.x] = spawned_objects[grid.x] or {}
      if not spawned_objects[grid.x][grid.z] then
        -- Create near grass
        spawned_objects[grid.x][grid.z] = { grass = factory.create("#grass", pos, _, _, grass_scale) }
        instance_counter = instance_counter + 1

        -- Create near trees
        local random_num = math.random(0,100)
        local random_scale = vmath.vector3(1+(math.random(1,4)/10))
        if random_num > tree_1_probability then
          spawned_objects[grid.x][grid.z].tree = factory.create("#tree1", pos, _, _, random_scale/1.3)
          instance_counter = instance_counter + 1
          local paper_delta = vmath.vector3(0.05, 1.24, 0.42)
          local rot = vmath.quat_rotation_x(0.36)
          spawn_paper(spawned_objects, grid, pos, paper_delta, rot, 1)
        elseif random_num > tree_2_probability then
          spawned_objects[grid.x][grid.z].tree = factory.create("#tree2", pos, _, _, random_scale/11)
          instance_counter = instance_counter + 1
          --spawn_paper(spawned_objects, grid, pos, 1)
        elseif random_num > tree_3_probability then
          spawned_objects[grid.x][grid.z].tree = factory.create("#tree3", pos, _, _, random_scale/3)
          instance_counter = instance_counter + 1
          --spawn_paper(spawned_objects, grid, pos, 1)
        end
      end
    end
  end
  --print("Instances", instance_counter)
end

local function recreate_world_around_player(spawned_objects)
  local hero_pos = get_normalized_hero_position()

  remove_far_grass_and_trees(spawned_objects, hero_pos)

  create_near_grass_and_trees(spawned_objects, hero_pos)
end

local objects_to_spawn = {
  {
    factory = "#zombie",
    pos = {vmath.vector3(-6,0,0)},
    rot = {vmath.quat_rotation_y(-30)},
    scale = {vmath.vector3(0.4)}
  }--[[,
  {
    factory = "#zombie_light",
    pos = {vmath.vector3(0,0,0)},
    rot = {vmath.quat_rotation_y(0)},
    scale = {vmath.vector3(1)},
    prop = {{specular = 1, smoothness = 0.5, cutoff = 0.5, color = vmath.vector3(0,1,0)}}
  }]]
}
 
--
-- Lifecycle

function init(self)
  math.randomseed(9)--os.clock()) -3
  self.spawned = {}
  self.spawned_objects = {}
  self.pos = go.get_world_position("main:/player/player")

  recreate_world_around_player(self.spawned_objects)
  timer.delay(0.3, true, function()
    recreate_world_around_player(self.spawned_objects)
  end)


  self.spawned = {}
  for i,obj in ipairs(objects_to_spawn) do
    for j,pos in ipairs(obj.pos) do
      self.spawned[i] = factory.create(obj.factory, pos, obj.rot[j], obj.prop and obj.prop[j], obj.scale[j])
    end
  end
  urls = {
    illumination_go = msg.url('illumination'),
    illumination = msg.url('illumination#illumination'),
    firefly = msg.url('firefly'),
    firefly_light = msg.url('firefly#light'),
    fireplace = msg.url('fireplace#light'),
    spot_red = msg.url('light_red'),
    spot_green = msg.url('light_green')
  }

  run_daycycle(self, 2)

--[[  go.animate(urls.spot_red, 'euler.y', go.PLAYBACK_LOOP_FORWARD, 360, go.EASING_LINEAR, 10, 0)
  go.animate(urls.spot_red, 'euler.z', go.PLAYBACK_LOOP_PINGPONG, -50, go.EASING_INOUTQUAD, 5, 0)
  go.animate(urls.spot_green, 'euler.y', go.PLAYBACK_LOOP_FORWARD, 360, go.EASING_LINEAR, 12, 0)
  go.animate(urls.spot_green, 'euler.z', go.PLAYBACK_LOOP_PINGPONG, -50, go.EASING_INOUTQUAD, 5, 0)
  go.animate(urls.fireplace, 'brightness', go.PLAYBACK_LOOP_PINGPONG, 0.8, go.EASING_INOUTQUAD, 1, 0)
  go.animate(urls.firefly, 'position', go.PLAYBACK_LOOP_PINGPONG, vmath.vector3(-6, 1, -4), go.EASING_INOUTQUAD, 25, 0)]]

  --illumination.set_debug(true)
end