--
-- Local

local pigeon = require "pigeon.pigeon"

local urls = { }

local daycycle = {
  {
    sunlight_direction = vmath.vector3(-70, 90, 0),
    sunlight_color = vmath.vector3(0.5, 0.5, 0.5),
    sunlight_brightness = 0.5,
    ambient_color = vmath.vector3(0.5, 0.5, 0.5),
    ambient_level = 0.3,
    fog_color = vmath.vector3(0),
    fog_level = 0.3,
    fog_distance_min = 6,
    fog_distance_max = 8,
    duration = 0
  },
  {
    sunlight_direction = vmath.vector3(-70, 80, 0),
    sunlight_color = vmath.vector3(0.3, 0.3, 0.9),
    sunlight_brightness = 0.6,
    ambient_color = vmath.vector3(0.2, 0.2, 0.6),
    ambient_level = 0.3,
    fog_color = vmath.vector3(0),
    fog_level = 0.9,
    fog_distance_min = 9,
    fog_distance_max = 15,
    duration = 0
  }
}

local function run_daycycle(self, index)
  local target = daycycle[index or 1]
  local duration = index and target.duration or 0

  go.cancel_animations(urls.illumination)
  go.animate(urls.illumination, 'sunlight_color', go.PLAYBACK_ONCE_FORWARD, target.sunlight_color, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'sunlight_brightness', go.PLAYBACK_ONCE_FORWARD, target.sunlight_brightness, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'ambient_color', go.PLAYBACK_ONCE_FORWARD, target.ambient_color, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'ambient_level', go.PLAYBACK_ONCE_FORWARD, target.ambient_level, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'fog_level', go.PLAYBACK_ONCE_FORWARD, target.fog_level, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'fog_color', go.PLAYBACK_ONCE_FORWARD, target.fog_color, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'fog_distance_min', go.PLAYBACK_ONCE_FORWARD, target.fog_distance_min, go.EASING_LINEAR, duration)
  go.animate(urls.illumination, 'fog_distance_max', go.PLAYBACK_ONCE_FORWARD, target.fog_distance_max, go.EASING_LINEAR, duration)
end

-- Distance between two 2d points
local function dist2d(x1, y1, x2, y2)
  return ((x2-x1)^2+(y2-y1)^2)^0.5 -- removed sqr on purpose
end

local grass_scale = 2
local grass_space = 4
local grass_fov = 12
local remove_grass_fov = 16

local tree_density = 15
local tree_1_probability = 100 - tree_density
local tree_2_probability = 100 - 2 * tree_density
local tree_3_probability = 100 - 3 * tree_density
local tree_4_probability = 100 - 4 * tree_density
--local candle_probability = 100 - 4.5 * tree_density

local function get_normalized_hero_position()
  local hero_pos = go.get_world_position("main:/player/player")
  hero_pos.x = math.floor(hero_pos.x)
  hero_pos.z = math.ceil(hero_pos.z)
  hero_pos.x = hero_pos.x - (hero_pos.x % grass_space)
  hero_pos.z = hero_pos.z - (hero_pos.z % grass_space)
  return hero_pos
end

local instance_counter = 0

local function remove_far_grass_and_trees(spawned_objects, hero_pos)
  for obj_x, z_column in pairs(spawned_objects) do
    for obj_z, objects in pairs(z_column) do
      if dist2d(hero_pos.x, hero_pos.z, obj_x, obj_z) > remove_grass_fov then
        -- Eventually remove far grass
        if objects.grass then
          go.delete(objects.grass)
          instance_counter = instance_counter - 1
        end

        -- Eventually remove trees
        if objects.tree then
          go.delete(objects.tree)
          instance_counter = instance_counter - 1
        end

        -- Eventually remove papers
        if objects.paper then
          go.delete(objects.paper)
          instance_counter = instance_counter - 1
        end

        -- Eventually remove lights
        if objects.light then
          go.delete(objects.light)
          instance_counter = instance_counter - 1
        end
        spawned_objects[obj_x][obj_z] = nil
      end
    end
  end
end

local papers = {}
papers[1] = {
  grid = {x = 4, z = 0},
  paper_model = "#paper1",
  paper_delta = vmath.vector3(0.05, 1.24, 0.42),
  paper_scale = vmath.vector3(0.18),
  paper_rot = vmath.quat_rotation_x(0.36),
  taken = false,
  model = "#tree1",
  model_scale = vmath.vector3(1),
  collected = false
}
papers[2] = {
  grid = {x = 0, z = -4},
  paper_model = "#paper1",
  paper_delta = vmath.vector3(0.617, 1.14, 0.05),
  paper_scale = vmath.vector3(0.2),
  paper_rot = vmath.quat_rotation_y(1.57),
  taken = false,
  model = "#tombstone",
  model_scale = vmath.vector3(0.4),
  light_delta = vmath.vector3(0.7, 1.14, 0.3),
  light_color = vmath.vector3(1,0,0),
  collected = false
}
papers[3] = {
  grid = {x = 0, z = 4},
  paper_model = "#paper1",
  paper_delta = vmath.vector3(0.0, 1.25, 0.24),
  paper_scale = vmath.vector3(0.2),
  paper_rot = vmath.quat_rotation_y(0),
  taken = false,
  model = "#crossstone",
  model_scale = vmath.vector3(0.12),
  light_delta = vmath.vector3(0.7, 1.14, 0.3),
  light_color = vmath.vector3(1,0,0),
  collected = false
}
papers[4] = {
  grid = {x = 0, z = 0},
  paper_model = "#paper1",
  paper_delta = vmath.vector3(0.7, 0.01, 0.6),
  paper_scale = vmath.vector3(0.25),
  paper_rot = vmath.quat_rotation_x(-1.57),
  taken = false,
  model = "#candle",
  model_scale = vmath.vector3(0.12),
  light_delta = vmath.vector3(0.7, 1.14, 0.3),
  light_color = vmath.vector3(1,0,0),
  collected = false
}

local spawned_papers_locations = {}

local function create_near_grass_and_trees(spawned_objects, hero_pos)
  for x = -grass_fov, grass_fov, grass_space do
    for z = -grass_fov, grass_fov, grass_space do
      local grid = vmath.vector3(hero_pos.x + x, 0, hero_pos.z + z)
      local pos = vmath.vector3(hero_pos.x + x, 0, hero_pos.z + z)
      if not spawned_objects[grid.x] then
        spawned_objects[grid.x] = {}
      end
      if not spawned_objects[grid.x][grid.z] then
        -- Create near grass
        spawned_objects[grid.x][grid.z] = spawned_objects[grid.x][grid.z] or {}

        for i,v in pairs(papers) do
          if v.grid.x == grid.x and v.grid.z == grid.z then
            if not spawned_objects[grid.x][grid.z].grass then
              spawned_objects[grid.x][grid.z].grass = factory.create("#grass", pos, _, _, grass_scale)
              instance_counter = instance_counter + 1
            end
            if not spawned_objects[grid.x][grid.z].tree then
              spawned_objects[grid.x][grid.z].tree = factory.create(v.model, pos, _, _, v.model_scale)
              instance_counter = instance_counter + 1
            end
            if (not v.collected) and (not spawned_objects[grid.x][grid.z].paper) then
              spawned_objects[grid.x][grid.z].paper = factory.create(v.paper_model, pos + v.paper_delta, v.paper_rot, _, v.paper_scale)
              instance_counter = instance_counter + 1
              spawned_papers_locations[spawned_objects[grid.x][grid.z].paper] = {x = grid.x, z = grid.z, papers_index = i}
            end
            if v.light_delta and (not spawned_objects[grid.x][grid.z].light) then
              spawned_objects[grid.x][grid.z].light = factory.create("#light", pos + v.light_delta, _,
              {specular = 1, smoothness = 0.5, cutoff = 0.5, color = v.light_color})
              instance_counter = instance_counter + 1
            end
          end
        end

        if not spawned_objects[grid.x][grid.z].grass then
          spawned_objects[grid.x][grid.z].grass = factory.create("#grass", pos, _, _, grass_scale)
          instance_counter = instance_counter + 1
        end

        -- Create near trees
        if not spawned_objects[grid.x][grid.z].tree then
          local random_num = math.random(0,100)
          local random_scale = vmath.vector3(1+(math.random(1,4)/10))
          if random_num > tree_1_probability then
            spawned_objects[grid.x][grid.z].tree = factory.create("#tree1", pos, _, _, random_scale/1.2)
            instance_counter = instance_counter + 1
          elseif random_num > tree_2_probability then
            spawned_objects[grid.x][grid.z].tree = factory.create("#tree2", pos, _, _, random_scale/11)
            instance_counter = instance_counter + 1
          elseif random_num > tree_3_probability then
            spawned_objects[grid.x][grid.z].tree = factory.create("#tree3", pos, _, _, random_scale/3)
            instance_counter = instance_counter + 1
          elseif random_num > tree_4_probability then
            spawned_objects[grid.x][grid.z].tree = factory.create("#tree4", pos, _, _, random_scale)
            instance_counter = instance_counter + 1
          --[[elseif random_num > candle_probability then
            spawned_objects[grid.x][grid.z].tree = factory.create("#candle", pos, _, _, random_scale/10)
            spawned_objects[grid.x][grid.z].light = factory.create("#light", pos, _,
            {specular = 1, smoothness = 0.5, cutoff = 0.5, color = vmath.vector3(0,0,1)})
            instance_counter = instance_counter + 2]]
          end
        end
      end
    end
  end
  --print("Instances", instance_counter)
end

local function recreate_world_around_player(spawned_objects)
  local hero_pos = get_normalized_hero_position()

  remove_far_grass_and_trees(spawned_objects, hero_pos)

  create_near_grass_and_trees(spawned_objects, hero_pos)
end

local objects_to_spawn = {
  {
    factory = "#zombie",
    pos = {vmath.vector3(-6,0,0)},
    rot = {vmath.quat_rotation_y(-30)},
    scale = {vmath.vector3(0.4)}
  }--[[,
  {
    factory = "#zombie_light",
    pos = {vmath.vector3(0,0,0)},
    rot = {vmath.quat_rotation_y(0)},
    scale = {vmath.vector3(1)},
    prop = {{specular = 1, smoothness = 0.5, cutoff = 0.5, color = vmath.vector3(0,1,0)}}
  }]]
}

local msg_remove_paper = hash("remove_paper")
 
--
-- Lifecycle

local function spawn_first_tree_with_paper(spawned_objects)
  local pos = vmath.vector3(0,0,0)
  spawned_objects[0] = {}
  spawned_objects[0][0] = {}

  -- Create first grass
  --spawned_objects[0][0] = { grass = factory.create("#grass", pos, _, _, grass_scale) }
  --instance_counter = instance_counter + 1

  -- Create first tree
  --spawned_objects[0][0].tree = factory.create("#tree1", pos, _, _, 0.8)
  --instance_counter = instance_counter + 1

  -- Create first paper
  local paper_delta = vmath.vector3(0.05, 1.24, 0.42)
  local rot = vmath.quat_rotation_x(0.36)  -- Create first grass
  pos = pos + paper_delta
  --spawned_objects[0][0].paper = factory.create("#paper"..1, pos, rot, _, vmath.vector3(0.17))
  spawned_objects[2][0].light = factory.create("#light", pos, _,
  {specular = 1, smoothness = 0.5, cutoff = 0.5, color = vmath.vector3(0,1,0)})
  instance_counter = instance_counter + 1--2
--  papers[1] = papers[1] - 1
  --spawned_papers_locations[spawned_objects[0][0].paper] = {x = 0, z = 0}
end

function init(self)
  math.randomseed(9)--os.clock()) -3
  self.spawned = {}
  self.spawned_objects = {}
  self.pos = go.get_world_position("main:/player/player")

  --spawn_first_tree_with_paper(self.spawned_objects)

  --local hero_pos = get_normalized_hero_position()
  --spawn_near_papers_with_object_and_grass(self.spawned_objects, hero_pos)

  recreate_world_around_player(self.spawned_objects)
  timer.delay(0.3, true, function()
    recreate_world_around_player(self.spawned_objects)
  end)

  self.spawned = {}
  for i,obj in ipairs(objects_to_spawn) do
    for j,pos in ipairs(obj.pos) do
      self.spawned[i] = factory.create(obj.factory, pos, obj.rot[j], obj.prop and obj.prop[j], obj.scale[j])
    end
  end
  urls = {
    illumination_go = msg.url('illumination'),
    illumination = msg.url('illumination#illumination'),
    firefly = msg.url('firefly'),
    firefly_light = msg.url('firefly#light'),
    fireplace = msg.url('fireplace#light'),
    spot_red = msg.url('light_red'),
    spot_green = msg.url('light_green')
  }

  run_daycycle(self, 2)

--[[  go.animate(urls.spot_red, 'euler.y', go.PLAYBACK_LOOP_FORWARD, 360, go.EASING_LINEAR, 10, 0)
  go.animate(urls.spot_red, 'euler.z', go.PLAYBACK_LOOP_PINGPONG, -50, go.EASING_INOUTQUAD, 5, 0)
  go.animate(urls.spot_green, 'euler.y', go.PLAYBACK_LOOP_FORWARD, 360, go.EASING_LINEAR, 12, 0)
  go.animate(urls.spot_green, 'euler.z', go.PLAYBACK_LOOP_PINGPONG, -50, go.EASING_INOUTQUAD, 5, 0)
  go.animate(urls.fireplace, 'brightness', go.PLAYBACK_LOOP_PINGPONG, 0.8, go.EASING_INOUTQUAD, 1, 0)
  go.animate(urls.firefly, 'position', go.PLAYBACK_LOOP_PINGPONG, vmath.vector3(-6, 1, -4), go.EASING_INOUTQUAD, 25, 0)]]

  --illumination.set_debug(true)

  pigeon.subscribe(msg_remove_paper)
end

local function remove_paper(object)
  -- Eventually remove papers
  if object.paper then
    go.delete(object.paper)
    instance_counter = instance_counter - 1
  end
end

function on_message(self, message_id, message, sender)
  if (message_id == msg_remove_paper) and message.paper_id then
    local paper = spawned_papers_locations[message.paper_id]
    remove_paper(self.spawned_objects[paper.x][paper.z])
    papers[paper.papers_index].collected = true
    spawned_papers_locations[message.paper_id] = nil
  end
end